---
layout: post
title: "테스트"
---

BPF의 핵심은 프로그램을 작성해서 커널 내 몆몆 지점에서 돌릴 수 있다는 것이다. (그래서 구글 프로젝트 제로의 Spectre 설명에도 (e)BPF가 등장한다.) 유연성과 편의성 간 타협이라는 측면에서 커널 프로그래밍과 커널 이용 사이의 영역을 채워 준다. 꽤 편하면서도 유연한 메커니즘이 있는데 사람들이 가만 놔뒀을 리 없다. 패킷 대신 다른 선형 데이터를 프로그램 입력으로 주고 반환 값 해석 방식을 나름대로 정하면 다른 모듈에서도 BPF를 사용할 수 있다.

리눅스의 seccomp(SECure COMPuting mode)]은 프로세스가 자신에게 허용되는 시스템 호출을 제한할 수 있는 메커니즘이다. 설령 프로세스가 탈취되더라도 피해를 최소화 하기 위한 방어책인데, 서버 프로그램들이 초기화를 마치고 본격적인 동작을 시작하기 전에 setuid() 등으로 특권을 버리는 것과 통하는 면이 있다. 원래는 안전 컴퓨팅 모드로 들어가면 4가지 시스템 호출(read(), write(), exit(), sigreturn())만 가능하다. 안전도 좋지만, 빡세다. 좀 더 유연하면 좋을 테고, 이왕이면 인자까지 보고 허용 여부를 결정할 수 있으면 좋을 것이다. 그래서 BPF가 도입됐다. 프로세스에 BPF 프로그램을 붙이면 그 프로세스가 시스템 호출을 할 때마다 BPF 프로그램이 실행된다. 프로그램 입력은 시스템 호출 번호와 인자들이고 반환 값에 따라 시스템 호출이 허용되거나 거절되거나 기타 방식으로 동작이 바뀐다.
